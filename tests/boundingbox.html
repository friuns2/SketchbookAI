<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive 3D Model Viewer with Bounding Box Visualization</title>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three":         "https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js",
                "GLTFLoader":    "https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/loaders/GLTFLoader.js",
                "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'GLTFLoader';
        import { OrbitControls } from 'OrbitControls';

        // Include the KHR_materials_pbrSpecularGlossiness extension
        class GLTFMaterialsPbrSpecularGlossinessExtension {
            constructor(parser) {
                this.parser = parser;
                this.name = 'KHR_materials_pbrSpecularGlossiness';
            }

            getMaterialType(materialIndex) {
                return THREE.MeshStandardMaterial;
            }

            extendMaterialParams(materialIndex, materialParams) {
                const parser = this.parser;
                const materialDef = parser.json.materials[materialIndex];

                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }

                const pbrSpecularGlossiness = materialDef.extensions[this.name];

                materialParams.color = new THREE.Color(1, 1, 1);
                materialParams.opacity = (pbrSpecularGlossiness.diffuseFactor !== undefined) ? pbrSpecularGlossiness.diffuseFactor[3] : 1.0;

                materialParams.roughness = 1.0 - (pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0);
                materialParams.metalness = 0.0;

                return Promise.all([
                    pbrSpecularGlossiness.diffuseTexture !== undefined ?
                        parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture) :
                        Promise.resolve(),
                    pbrSpecularGlossiness.specularGlossinessTexture !== undefined ?
                        parser.assignTexture(materialParams, 'glossinessMap', pbrSpecularGlossiness.specularGlossinessTexture) :
                        Promise.resolve()
                ]);
            }
        }

        let scene, camera, renderer, controls, model, clock;
        let boxHelper;

        init();
        loadGLBModel();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 55);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Orbit Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-3, 10, -10);
            scene.add(dirLight);

            // Clock for animation
            clock = new THREE.Clock();

            // Start animation loop
            animate();
        }

        function loadGLBModel() {
            // GLTFLoader to load .glb files
            const loader = new GLTFLoader();

            // Register the KHR_materials_pbrSpecularGlossiness extension
            loader.register(parser => new GLTFMaterialsPbrSpecularGlossinessExtension(parser));

            loader.load('apple.glb', function (gltf) {
                model = gltf.scene;
                model.traverse((child) => {
                    if (child.isMesh) {
                        // Enable shadow casting and receiving for all meshes
                        child.castShadow = true;
                        child.receiveShadow = true;

                     
                    }
                });
                model.updateMatrixWorld(true);

                // Compute the bounding box
                const combinedBoundingBox = new THREE.Box3().setFromObject(model);

                scene.add(model);

                // Visualize the combined bounding box
                boxHelper = new THREE.BoxHelper(model, 0xff0000);
                scene.add(boxHelper);

            }, undefined, function (error) {
                console.error('An error occurred while loading the model:', error);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (boxHelper) {
                boxHelper.update();
            }
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>